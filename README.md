# food-tracker
Track and rate meals

This project was created from Apple's Start Developing iOS Apps

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html#//apple_ref/doc/uid/TP40015214-CH2-SW1

Below is a list of notes taken from the site that helped me and may be important for junior developers... enjoy!

Briefly Covers:

Fixing Stack Views
Configuring text field’s keyboard
About Delegates
Set up the UITextFieldDelegate
	First Responders
Work With View Controllers
Image View Aspect Ratios & Interactions
Tap gesture recognizer
	Create an Image Picker to Respond to User Taps
Implement A Custom Control
	Custom UIView
	Add Buttons to the View (programmatically)
	Implement the Button Action
Define Your Data Model
	Unit Tests
Create a Table View
	Turn off Cell highlighting when user taps
	Turn off user interaction with cell contents but allow click to segue
UITableViewDataSource protocol and UITableViewDelegate protocol
Implement Navigation
Create an Unwind Segue 1/2
Disable Saving When the User Doesn't Enter an Item Name
Cancel button - dismissViewController
Implement Edit and Delete Behavior
Update the implementation of unwindToMealList(_:) to add or replace meals 2/2
Cancel an Edit to an Existing Meal
Support Deletion
Persist Data











----------------------------------------------------------------
Fixing Stack Views 
	AL issues

Stack View > Pin > Update Frames: Items of New Constraints

Do this with the objects causing issues:

select the object go to siin (size inspector)
	at bottom: 
		intrinsic size: Placeholder


----------------------------------------------------------------
Configuring text field’s keyboard

Make sure the text field is selected.

In Atin (attributes inspector) > Return Key
	select Done
		Makes the default "Return" key show "Done"

In Atin, 
	select: Auto-enable Return Key
		Makes it impossible to tap "Done" key before typing text
			ensures users can never enter an empty string

------------------------------------------------------------------

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson3.html#//apple_ref/doc/uid/TP40015214-CH22-SW1

UITextFieldDelegate

When accepting user input from a text field, you need some help from a text field delegate

About Delegates:

	A delegate is an object that acts on behalf of, or in coordination with, another object

	-The delegating object— "the text field" 
		—keeps a reference for the other object 
			which is:
	—the delegate— "the ViewController"

	At the appropriate time, the delegating object sends a message to the delegate
		The message tells the delegate about an event that the delegating object is about to handle or has just handled. 
		
	The delegate may respond by for example: 
		updating the appearance or state of itself or of other objects in the app
		or returning a value that affects how an impending event is handled.


A text field’s delegate communicates with the text field while its text is being edited, and knows when important events occur
	—such as when a user starts or stops editing text. 
The delegate can use this information to: 
	save or clear data at the right time, dismiss the keyboard, and so on.

Any object can serve as a delegate for another object as long as it conforms to the appropriate protocol. 
	The protocol that defines a text field’s delegate is called UITextFieldDelegate. 
		In this case, because ViewController keeps a reference to the text field, you’ll make ViewController the text field’s delegate.

-------------------------------------------------------------

Set up the UITextFieldDelegate

We need the ViewController to adopt the UITextFieldDelegate protocol:

class ViewController: UIViewController, UITextFieldDelegate

Set VC as the delegate of the text field and implement some of its behavior to handle the text field's user input

In viewDidLoad()
	Add:
	nameTextField.delegate = self

The "self" refers to the ViewController class, because it’s referenced inside the scope of the ViewController class definition.

NOW the VC is a delegate for nameTextField

-----------------------------------------------

	First Responders

When the user taps a text field, it automatically becomes first responder. 
	the first responder is an object that is first on the line for receiving many kinds of app events, 
		includes key events, motion events, and action messages, among others. 
	In other words, many of the events generated by the user are initially routed to the first responder.

When a user wants to finish editing the text field, the text field needs to resign its first-responder status. Because the text field will no longer be the active object in the app, events need to get routed to a more appropriate object.

This is where your implementation of UITextFieldDelegate methods comes in. You need to specify that the text field should resign its first-responder status when the user taps a button to end editing in the text field. You do this in the textFieldShouldReturn(_:) method, which gets called when the user taps Return (or in this case, Done) on the keyboard.


// From UITextFieldDelegate called when "Return" taped on keyboard
func textFieldShouldReturn(textField: UITextField) -> Bool {
    // Hide the keyboard.
    textField.resignFirstResponder()
    return true
}

// From UITextFieldDelegate called after textField resigns first responder
func textFieldDidEndEditing(textField: UITextField) {
	// opportunity to read the information entered into the text field 
	// and do something with it... like:
    myLabel.text = textField.text
}

--------------------------------------------------------------------------------------------------------------------------------------
Work With View Controllers

UIViewController methods get called as follows:

viewDidLoad()—
	Called when the view controller’s content view (the top of its view hierarchy) is created and loaded from a storyboard. 
	This method is intended for initial setup. However, because views may be purged due to limited resources in an app, there is no guarantee that it will be called only once.

viewWillAppear()—
	Intended for any operations that you want always to occur before the view becomes visible. 
	Because a view’s visibility may be toggled or obscured by other views, this method is always called immediately before the content view appears onscreen.

viewDidAppear()—
	Intended for any operations that you want to occur as soon as the view becomes visible, such as fetching data or showing an animation. 
	Because a view’s visibility may be toggled or obscured by other views, this method is always called immediately after the content view appears onscreen.


-------------------------------------------------------------------

Image View Aspect Ratios & Interactions

Pin:
Select: Aspect Ratio.
	Your image view now has a 1:1 aspect ratio, 
		so it will always show a square.

In Atin > Interaction
	select: User Interaction Enabled checkbox



---------------------
******
Tap gesture recognizer

Object library:
Tap Gesture Recognizer object
Drag and place it on top of the image view (or whatever)
The Tap Gesture Recognizer appears in the scene dock

To connect the gesture recognizer to the ViewController.swift code

Control-drag from the gesture recognizer (in the scene dock) to SC
Connection: Action
Type: UITapGestureRecognizer
Name: selectImageFromPhotoLibrary

-------------------------------------------------
Create an Image Picker to Respond to User Taps

An image picker controller manages a UI for taking pictures and for choosing saved images to use in your app.
	Just as you need a text field delegate when you work with a text field, you need an image picker controller delegate to work with an image picker controller. 
	The name of that delegate protocol is UIImagePickerControllerDelegate
	the object that you’ll define as the image picker controller’s delegate is ViewController



UIImagePickerControllerDelegate and UINavigationControllerDelegate protocols


Add to class:
	UIImagePickerControllerDelegate, UINavigationControllerDelegate

To implement the selectImageFromPhotoLibrary(_:) action method:

Add:
	// Make sure to hide the keyboard.
	nameTextField.resignFirstResponder()

Add this code to create an image picker controller:
	// UIImagePickerController is a VC that lets user pick media from their photo library.
	let imagePickerController = UIImagePickerController()

Add:
	// Only allow photos to be picked, not taken.
	imagePickerController.sourceType = .PhotoLibrary

Add this code to set the image picker controller’s delegate to ViewController:
	// Make sure ViewController is notified when the user picks an image.
	imagePickerController.delegate = self

Add:
	presentViewController(imagePickerController, animated: true, completion: nil)

		The method asks ViewController to present the view controller defined by imagePickerController. Passing true to the animated parameter animates the presentation of the image picker controller. The completion parameter refers to a completion handler, a piece of code that executes after this method completes. Because you don’t need to do anything else, you indicate that you don’t need to execute a completion handler by passing in nil.

After an image picker controller is presented, its behavior is handed off to its delegate. To give users the ability to select a picture, you’ll need to implement two of the delegate methods defined in 

UIImagePickerControllerDelegate:

// From UIImagePickerControllerDelegate called when image picker’s Cancel button tapped 
// opportunity to dismiss the UIImagePickerController (and optionally, do any necessary cleanup)
func imagePickerControllerDidCancel(picker: UIImagePickerController) {
    // Dismiss the picker if the user canceled.
    dismissViewControllerAnimated(true, completion: nil)
}

// From UIImagePickerControllerDelegate called when photo selected
//opportunity to do something with image ex: display in UI
func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) {
    // The info dictionary contains multiple representations of the image, and this uses the original.
    let selectedImage = info[UIImagePickerControllerOriginalImage] as! UIImage
    
    // Set photoImageView to display the selected image.
    photoImageView.image = selectedImage
    
    // Dismiss the picker.
    dismissViewControllerAnimated(true, completion: nil)
}

---------------------------------------------------------------
---------------------------------------------------------------
Implement A Custom Control

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson5.html#//apple_ref/doc/uid/TP40015214-CH19-SW1


	Custom UIView

Every UIView subclass that implements an initializer must include an implementation of init?(coder:). The Swift compiler knows this, and offers a fix-it to make this change in your code. Fix-its are provided by the compiler as potential solutions to errors in your code.

class RatingControl: UIView {

    // MARK: Initialization
    
    required init?(coder aDecoder: NSCoder) {
        
        super.init(coder: aDecoder)
    }
}

Add a new View to SB and add the idin class

	Add Buttons to the View (programmatically)

under super.init(coder: aDecoder)
Add:	
	let button = UIButton(frame: CGRect(x: 0, y: 0, width: 44, height: 44))
    button.backgroundColor = UIColor.redColor()
    addSubview(button)


Layout the buttons:
Use code:
	override func intrinsicContentSize() -> CGSize {
    return CGSize(width: 240, height: 44)
}


Add action:
	func ratingButtonTapped(button: UIButton) {
}


In init?(coder:)
Before the addSubview(button) line, add this:
	button.addTarget(self, action: #selector(RatingControl.ratingButtonTapped(_:)), forControlEvents: .TouchDown)

You’re familiar with the target-action pattern because you’ve used it to link elements in your storyboard to action methods in your code. 
Above, you’re doing the same thing, except you’re creating the connection in code. 

	You’re attaching the ratingButtonTapped(_:) action method 
	to the button object, 
	which will be triggered whenever the .TouchDown event occurs. 
		This event signifies that the user has pressed on a button. 
	You set the target to self, 
		which in this case is the RatingControl class, 
			because that’s where the action is defined.
	The #selector expression returns the Selector value for the provided method. 
		A selector is an opaque value that identifies the method. 
			Older APIs used selectors to dynamically invoke methods at runtime. While newer APIs have largely replaced selectors with blocks, many older methods—like performSelector(_:) and addTarget(_:action:forControlEvents:)—still take selectors as arguments. 
			In this example, the #selector(RatingControl.ratingButtonTapped(_:)) expression returns the selector for your ratingButtonTapped(_:) action method. 
			This lets the system call your action method when the button is tapped.
Note that because you’re not using Interface Builder, you don’t need to define your action method with the IBAction attribute; you just define the action like any other method.


override func layoutSubviews() {
    var buttonFrame = CGRect(x: 0, y: 0, width: 44, height: 44)
    
    // Offset each button's origin by the length of the button plus spacing.

    for (index, button) in ratingButtons.enumerate() {
        buttonFrame.origin.x = CGFloat(index * (44 + 5))
        button.frame = buttonFrame
    }
}

This code creates a frame, and uses a for-in loop to iterate over all of the buttons to set their frames.

The enumerate() method returns a collection that contains elements in the ratingButtons array paired with their indexes. 
	This is a collection of tuples—groupings of values—and in this case, each tuple contains an index and a button. 
	For each tuple in the collection, the for-in loop binds the values of the index and button in that tuple to local variables, index and button. 
	You use the index variable to compute a new location for the button frame and set it on the button variable. 
	The frame locations are set equal to a standard button size of 44 points and 5 points of padding, multiplied by index.


	Implement the Button Action

The indexOf(_:) method attempts to find the selected button in the array of buttons and to return the index at which it was found. 
	This method returns an optional Int because the instance you’re searching for might not exist in the collection you’re searching. 
	However, because the only buttons that trigger this action are the ones you created and added to the array yourself, you can be sure that searching for the button will return a valid index. 
	In this case, you can use the force unwrap operator (!) to access the underlying index value. 
	You add 1 to that index to get the corresponding rating. 
	You need to add 1 because arrays are indexed starting with 0.

Update the rating property to include this property observer:
	var rating = 0 {
	didSet {
    	setNeedsLayout()
	}
	}
A property observer observes and responds to changes in a property’s value. 
Property observers are called every time a property’s value is set, and can be used to perform work immediately before or after the value changes. 
	Specifically, the didSet property observer is called immediately after the property’s value is set. 
	Here, you include a call to setNeedsLayout(), which will trigger a layout update every time the rating changes. 
		This ensures that the UI is always showing an accurate representation of the rating property value.

--------------------------------------------------------------------------------------------------------------------------------------


Define Your Data Model

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson6.html#//apple_ref/doc/uid/TP40015214-CH20-SW1

Test Your Data

	Unit Tests

Add yourself:
First of all just add new Target via 
	File > New > Target... 
		select iOS Unit Testing Bundle. 
			Done.

--------------------------------------------------------------------------------------------------------------------------------------

Create a Table View

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson7.html#//apple_ref/doc/uid/TP40015214-CH8-SW1

***
	Turn off Cell highlighting when user taps

Outline > TV > Cell > atin > Selection: None

	Turn off user interaction with cell contents but allow click to segue

Outline > TV > Cell > atin > Interaction > 
	deselect the User Interaction Enabled checkbox.
		The custom rating control class set to be interactive, but it doesn’t need to be interactive when it’s displayed in this table view cell. 

---------------------------------

UITableViewDataSource protocol and UITableViewDelegate protocol

Before you can display dynamic data in your table view cells, you need to create outlet connections between the views (objects) in your storyboard and the code that represents the table view cell in MealTableViewCell.swift.


To display dynamic data, a table view needs two important helpers: 
	a data source and a delegate. 
A table view data source, as implied by its name, 
	supplies the table view with the data it needs to display. 
A table view delegate helps the table view manage cell selection, row heights, and other aspects related to displaying the data. 

**
By default, UITableViewController and its subclasses adopt the necessary protocols to make the table view controller both a data source (UITableViewDataSource protocol) and a delegate (UITableViewDelegate protocol) for its associated table view. 
	Your job is to implement the appropriate protocol methods in your table view controller subclass so that your table view has the correct behavior.

A functioning table view requires three table view data source methods.

func numberOfSectionsInTableView(tableView: UITableView) -> Int

func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int

func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell

The first of these is numberOfSectionsInTableView(_:), which tells the table view how many sections to display. 
	Sections are visual groupings of cells within table views, which is especially useful in table views with a lot of data. 
		For a simple table view like the one in the FoodTracker app, you just need the table view to display a single section, so the implementation of the numberOfSectionsInTableView(_:) data source method is straightforward.

The next data source method, tableView(_:numberOfRowsInSection:), tells the table view how many rows to display in a given section. 
	A table view defaults to having a single section, which is just what you need for the FoodTracker app. 
		Each meal should have its own row in that section. 
			That means that the number of rows should be the number of Meal objects in your meals array.


The last data source method, tableView(_:cellForRowAtIndexPath:), configures and provides a cell to display for a given row. 
	Each row in a table view has one cell, and that cell determines the content that appears in that row and how that content is laid out.

For table views with a small number of rows, all rows may be onscreen at once, so this method gets called for each row in your table. 
	But table views with a large number of rows display only a small fraction of their total items at a given time. 
		It’s most efficient for table views to only ask for the cells for rows that are being displayed, and that’s what tableView(_:cellForRowAtIndexPath:) allows the table view to do.

For any given row in the table view, you configure the cell by fetching the corresponding Meal in the meals array, and then setting the cell’s properties to corresponding values from the Meal class.




--------------------------------------------------------------------------------------------------------------------------------------
Implement Navigation

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson8.html#//apple_ref/doc/uid/TP40015214-CH16-SW1


Store New Meals in the Meal List

***
Create an Unwind Segue 1/2

In the prepareForSegue(_:sender:) method, add the following if statement:
if saveButton === sender {
}
This code uses the identity operator (===) to check that the object referenced by the saveButton outlet is the same object instance as sender. If it is, the if statement is executed.

In the if statement, add the following code:
let name = nameTextField.text ?? ""
let photo = photoImageView.image
let rating = ratingControl.rating
This code creates constants from the current text field text, selected image, and rating in the scene.
Notice the nil coalescing operator (??) in the name line. The nil coalescing operator is used to return the value of an optional if the optional has a value, or return a default value otherwise. Here, the operator unwraps the optional String returned by nameTextField.text (which is optional because there may or may not be text in the text field), and returns that value if it’s a valid string. But if it’s nil, the operator the returns the empty string ("") instead.
In the if statement, add the following code:
// Set the meal to be passed to MealTableViewController after the unwind segue.
meal = Meal(name: name, photo: photo, rating: rating)
This code configures the meal property with the appropriate values before segue executes.

In MealTableViewController:

@IBAction func unwindToMealList(sender: UIStoryboardSegue) {
}

In the unwindToMealList(_:) action method, add the following if statement:
if let sourceViewController = sender.sourceViewController as? MealViewController, meal = sourceViewController.meal {
}
There’s quite a lot happening in the condition for this if statement.
This code uses the optional type cast operator (as?) to try to downcast the source view controller of the segue to type MealViewController. You need to downcast because sender.sourceViewController is of type UIViewController, but you need to work with MealViewController.
The operator returns an optional value, which will be nil if the downcast wasn’t possible. If the downcast succeeds, the code assigns that view controller to the local constant sourceViewController, and checks to see if the meal property on sourceViewController is nil. If the meal property is non-nil, the code assigns the value of that property to the local constant meal and executes the if statement.
If either the downcast fails or the meal property on sourceViewController is nil, the condition evaluates to false and the if statement doesn’t get executed.
In the if statement, add the following code:
// Add a new meal.
let newIndexPath = NSIndexPath(forRow: meals.count, inSection: 0)
This code computes the location in the table view where the new table view cell representing the new meal will be inserted, and stores it in a local constant called newIndexPath.
In the if statement, below the previous line of code, add the following code:
meals.append(meal)
This adds the new meal to the existing list of meals in the data model.
In the if statement, below the previous line of code, add the following code:
tableView.insertRowsAtIndexPaths([newIndexPath], withRowAnimation: .Bottom)
This animates the addition of a new row to the table view for the cell that contains information about the new meal. The .Bottom animation option shows the inserted row slide in from the bottom.

Now you need to create the actual unwind segue to trigger this action method.

To link the Save button to the unwindToMealList action method

Open your storyboard.
On the canvas, Control-drag from the Save button to the Exit item at the top of the meal scene.

Choose unwindToMealList: from the shortcut menu.
Now, when users tap the Save button, they navigate back to the meal list scene, during which process the unwindToMealList(_:) action method is called.

---------------------------------------------

Disable Saving When the User Doesn't Enter an Item Name

// method gets called when an editing session begins, or when the keyboard gets displayed.
    // This code disables the Save button while the user is editing the text field.
    func textFieldDidBeginEditing(textField: UITextField) {
        // Disable the Save button while editing.
        saveButton.enabled = false
    }

//  helper method to disable the Save button if the text field is empty.
    func checkValidMealName() {
        // Disable the Save button if the text field is empty.
        let text = nameTextField.text ?? ""
        saveButton.enabled = !text.isEmpty
    }

// first line calls checkValidMealName() to check if the text field has text in it, which enables the Save button if it does. 
    // The second line sets the title of the scene to that text.
    func textFieldDidEndEditing(textField: UITextField) {
        
        checkValidMealName()
        navigationItem.title = textField.text
        
    }

In viewDidLoad
// Enable the Save button only if the text field has a valid Meal name.
checkValidMealName()


---------------------
Cancel button - dismissViewController

wire up the cancel button
add
dismissViewControllerAnimated(true, completion: nil)



--------------------------------------------------------------------------------------------------------------------------------------

Implement Edit and Delete Behavior

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson9.html#//apple_ref/doc/uid/TP40015214-CH9-SW1

Recall from earlier that the prepareForSegue(_:sender:) method is called before any segue gets executed. 
You can use this method to identify which segue is occurring, and display the appropriate information in the meal scene. 
You’ll differentiate the segues based on the identifiers you assigned to them earlier: AddItem (modal segue) and ShowDetail (show segue).

let mealDetailViewController = segue.destinationViewController as! MealViewController

This code tries to downcast the destination view controller of the segue to a MealViewController using the forced type cast operator (as!). Notice that this operation has an exclamation mark (!) instead of a question mark (?) at the end, like you’ve seen so far with type cast operators. This means that the operator performs a forced type cast. If the cast is successful, the local constant mealDetailViewController gets assigned the value of segue.destinationViewController cast as type MealViewController. If the cast is unsuccessful, the app should crash at runtime.
Only use a forced cast if you’re absolutely certain that the cast will succeed—and that if it fails, something has gone wrong in the app and it should crash. Otherwise, downcast using as?.


// Get the cell that generated this segue.
if let selectedMealCell = sender as? MealTableViewCell {
}
This code tries to downcast sender to a MealCell using the optional type cast operator (as?). If the cast is successful, the local constant selectedMealCell gets assigned the value of sender cast as type MealTableViewCell, and the if statement proceeds to execute. If the cast is unsuccessful, the expression evaluates to nil and the if statement isn’t executed.

let indexPath = tableView.indexPathForCell(selectedMealCell)!
let selectedMeal = meals[indexPath.row]
mealDetailViewController.meal = selectedMeal

This code fetches the Meal object corresponding to the selected cell in the table view. It then assigns that Meal object to the meal property of the destination view controller, an instance of MealViewController. (You’ll configure MealViewController to display the information from its meal property when it loads.)


-------------------------------------------------

Update the implementation of unwindToMealList(_:) to add or replace meals 2/2


In MealTableViewController.swift, find the unwindToMealList(_:) method.

if let selectedIndexPath = tableView.indexPathForSelectedRow {
}
This code checks whether a row in the table view is selected. If it is, that means a user tapped one of the table views cells to edit a meal. In other words, this if statement gets executed if an existing meal is being edited.

// Update an existing meal.
meals[selectedIndexPath.row] = meal
tableView.reloadRowsAtIndexPaths([selectedIndexPath], withRowAnimation: .None)
The first line updates the appropriate entry in meals to store the updated meal information. The second line reloads the appropriate row in the table view to display the changed data.


else {
    // Add a new meal.
    let newIndexPath = NSIndexPath(forRow: meals.count, inSection: 0)
    meals.append(meal)
    tableView.insertRowsAtIndexPaths([newIndexPath], withRowAnimation: .Bottom)
}

The else clause executes when there’s no selected row in the table view, which means a user tapped the Add button to get to the meal scene. In other words, this else statement gets executed if a new meal is being added.

--------------------------------------
Cancel an Edit to an Existing Meal

In the cancel(_:) action method, before dismissViewControllerAnimated, 
	add the following code:


This creates a Boolean value that indicates whether the view controller that presented this scene is of type UINavigationController. 

As the constant name isPresentingInAddMealMode indicates, this means that the meal scene was presented using the Add button. 
This is because the meal scene is embedded in its own navigation controller when it’s presented in this manner, which means that navigation controller is what presents it.
After the line you just added, add the following if statement, and move the line that calls dismissViewControllerAnimated inside of it:

if isPresentingInAddMealMode {
    dismissViewControllerAnimated(true, completion: nil)
}

Whereas before, the call to dismissViewControllerAnimated happened anytime the cancel(_:) method got called, it now only happens when isPresentingInAddMealMode is true.

Right after the if statement, add this else clause:

else {
    navigationController!.popViewControllerAnimated(true)
}

This is now an if statement with an else clause that executes the code within the if statement only when isPresentingInAddMealMode is true, and executes the code within the else clause otherwise.
The else clause gets executed when the meal scene was pushed onto the navigation stack on top of the meal list scene. The code within the else clause executes a method called popViewControllerAnimated, which pops the current view controller (meal scene) off the navigation stack of navigationController and performs an animation of the transition.



-------------------------------------------------------------------------------------------------------------

Support Deletion


Add Edit button to TV

Below the super.viewDidLoad() line, add the following line of code:

// Use the edit button item provided by the table view controller.
navigationItem.leftBarButtonItem = editButtonItem()

This creates a special type of bar button item that has editing behavior built into it. It then adds this button to the left side of the navigation bar in the meal list scene.


To delete a meal

In TVController

// Override to support editing the table view.
override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
    if editingStyle == .Delete {
        // Delete the row from the data source
        tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
    } else if editingStyle == .Insert {
        // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view
    }
}

Below the comment that says 
	// Delete the row from the data source 
add the following line of code:

meals.removeAtIndex(indexPath.row)

This code removes the Meal object to be deleted from meals. The line after it, which is part of the template implementation, deletes the corresponding row from the table view.

--------------------------------------------------------------------------------------------------------------

Persist Data

https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson10.html#//apple_ref/doc/uid/TP40015214-CH14-SW1


saving a meal list across FoodTracker app sessions

struct PropertyKey {
    static let nameKey = "name"
    static let photoKey = "photo"
    static let ratingKey = "rating"
}

Each constant corresponds to one of the three properties on Meal. The static keyword indicates that this constant applies to the structure itself, not an instance of the structure. These values will never change.

To be able to encode and decode itself and its properties, the Meal class needs to conform to to the NSCoding protocol. To conform to NSCoding, the Meal needs to subclass NSObject. NSObject is considered a base class that defines a basic interface to the runtime system.

To subclass NSObject and conform to NSCoding

class Meal: NSObject, NSCoding {

The NSCoding protocol declares two methods that any class that adopts to it must implement so that instances of that class can be encoded and decoded:

func encodeWithCoder(aCoder: NSCoder)
init(coder aDecoder: NSCoder)

The encodeWithCoder(_:) method prepares the class’s information to be archived, and the initializer unarchives the data when the class is created. You need to implement both the encodeWithCoder(_:) method and the initializer for the data to save and load properly.


func encodeWithCoder(aCoder: NSCoder) {

	//method encodes any type of object
    aCoder.encodeObject(name, forKey: PropertyKey.nameKey)

    aCoder.encodeObject(photo, forKey: PropertyKey.photoKey)

    // method encodes an integer
    aCoder.encodeInteger(rating, forKey: PropertyKey.ratingKey)
}

With the encoding method written, implement the initializer to decode the encoded data.

To implement the initializer to load the meal

Below the encodeWithCoder(_:) method, add the following initializer:

required convenience init?(coder aDecoder: NSCoder) {
    let name = aDecoder.decodeObjectForKey(PropertyKey.nameKey) as! String
    
    // Because photo is an optional property of Meal, use conditional cast.
    let photo = aDecoder.decodeObjectForKey(PropertyKey.photoKey) as? UIImage
    
    let rating = aDecoder.decodeIntegerForKey(PropertyKey.ratingKey)
    
    // Must call designated initializer.
    self.init(name: name, photo: photo, rating: rating)
}

The required keyword means this initializer must be implemented on every subclass of the class that defines this initializer.

Convenience initializers are secondary, supporting initializers that need to call one of their class’s designated initializers. 
Designated initializers are the primary initializers for a class. 
They fully initialize all properties introduced by that class and call a superclass initializer to continue the initialization process up the superclass chain. 
Here, you’re declaring this initializer as a convenience initializer because it only applies when there’s saved data to be loaded.
The question mark (?) means that this is a failable initializer that might return nil.

The decodeObjectForKey(_:) method unarchives the stored information stored about an object.
The return value of decodeObjectForKey(_:) is AnyObject, which you downcast in the code above as a String to assign it to a name constant. 
You downcast the return value using the forced type cast operator (as!) because if the object can’t be cast as a String, or if it’s nil, something has gone wrong and the error should cause a crash at runtime.

You downcast this return value of decodeObjectForKey(_:) as a UIImage to be assigned to a photo constant. In this case, you downcast using the optional type cast operator (as?), because the photo property is an optional, so the value might be a UIImage, or it might be nil. You need to account for both cases.

The decodeIntegerForKey(_:) method unarchives an integer. Because the return value of decodeIntegerForKey is Int, there’s no need to downcast the decoded value.

As a convenience initializer, this initializer is required to call one of its class’s designated initializers before completing. As the initializer’s arguments, you pass in the values of the constants you created while archiving the saved data.



Because the other initializer you defined on the Meal class, init?(name:photo:rating:), is a designated initializer, its implementation needs to call to its superclass’s initializer.

add:
	    super.init()


Next, you need a persistent path on the file system where data will be saved and loaded, so you know where to look for it.

To create a file path to data

// MARK: Archiving Paths
 
static let DocumentsDirectory = NSFileManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask).first!
static let ArchiveURL = DocumentsDirectory.URLByAppendingPathComponent("meals")

You mark these constants with the static keyword, which means they apply to the class instead of an instance of the class. Outside of the Meal class, you’ll access the path using the syntax Meal.ArchiveURL.path!.


Save and Load the Meal List

Now that you can save and load an individual meal, you need to save and load the meal list whenever a user adds, edits, or removes a meal.

To implement the method to save the meal list

in MealTableViewCOntroller

add:
// MARK: NSCoding

func saveMeals() {
    let isSuccessfulSave = NSKeyedArchiver.archiveRootObject(meals, toFile: Meal.ArchiveURL.path!)
    if !isSuccessfulSave {
        print("Failed to save meals...")
    }
}

This method attempts to archive the meals array to a specific location, and returns true if it’s successful. It uses the constant Meal.ArchiveURL that you defined in the Meal class to identify where to save the information.
But how do you quickly test whether the data saved successfully? Use print to print a message to the console. For example, print a failure message if the meals fail to save successfully.

To implement the method to load the meal list

func loadMeals() -> [Meal]? {
    return NSKeyedUnarchiver.unarchiveObjectWithFile(Meal.ArchiveURL.path!) as? [Meal]
}

This method has a return type of an optional array of Meal objects, meaning that it might return an array of Meal objects or might return nothing (nil).

This method attempts to unarchive the object stored at the path Meal.ArchiveURL.path! and downcast that object to an array of Meal objects. 
This code uses the as? operator so that it can return nil when appropriate. Because the array may or may not have been stored, it’s possible that the downcast will fail, in which case the method should return nil.

With these methods implemented, you need to add code to save and load the list of meals whenever a user adds, removes, or edits a meal.

in unwindToMealList(_:)

Add:
// Save the meals.
saveMeals()

in tableView(_:commitEditingStyle:forRowAtIndexPath:)

Add:
//saves meals array whenever a meal is deleted
saveMeals()


Now that meals are saved at the appropriate times, you need to make sure that meals get loaded at the appropriate time. This should happen every time the meal list scene loads, which means the appropriate place to load the stored data is in viewDidLoad.

In MealTableViewController.swift, find the viewDidLoad() method:

Add:
 // Load any saved meals, otherwise load sample data.
    if let savedMeals = loadMeals() {
        meals += savedMeals
    } else {
        // Load the sample data.
        loadSampleMeals()
        }



https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Resources.html#//apple_ref/doc/uid/TP40015214-CH15-SW1


























